/**
* @file TParticleSimData.cc
* @class TParticleSimData
* @brief Define the sim data structure for each muon counter station for the output ROOT file
*
* A ROOT dictionary for this class is generated by the Makefile
* @author Simone Riggi
* @date 22/12/2010
*/

#include <TParticleSimData.hh>
#include <TScintHit.hh>
#include <TPMTHit.hh>
#include <Utilities.hh>

#include <G4MuonCounterSimulator.hh>
#include <G4MuonCounterConstruction.hh>

#include <TVector3.h>
#include <TRandom.h>
#include <TRandom3.h>


#include <vector>
#include <algorithm>

using namespace G4MuonCounterSimulatorUSC;
using namespace std;

TParticleSimData::TParticleSimData(){

	fId= -999;
	fPDGCode= -999;

	fPosition(0);
	fGlobalPosition(0);
	fDirection(0);
	fMomentum(0);
	fEnergy= -999;
	fTheta= -999;
	fPhi= -999;
	fTime= -999;

	fHitSigmaX= 4;
	fHitSigmaY= 4;
	fHitSigmaZ= 4;

	StripSeparation= 1;
	
	fScintHitCollection.clear();
	fScintHitCollection.resize(0);

	fSelScintHitCollection.clear();
	fSelScintHitCollection.resize(0);

	fPMTHitCollection.clear();
	fPMTHitCollection.resize(0);

	fTrackPointCollection.clear();
	fTrackPointCollection.resize(0);

  fStripMultiplicity.clear();
	fStripMultiplicity.resize(0);

	fAverageXHit.clear();
	fAverageXHit.resize(0);

	fStripMultiplicityX.clear();
	fStripMultiplicityX.resize(0);
	
	fRX.clear();
	fRX.resize(0);

	fAverageYHit.clear();
	fAverageYHit.resize(0);

	fStripMultiplicityY.clear();
	fStripMultiplicityY.resize(0);

	fRY.clear();
	fRY.resize(0);

	fDetectorData= 0;

}//close constructor

TParticleSimData::~TParticleSimData(){

}//close destructor


void TParticleSimData::CreateTrackPoints(){

	//## Create collection of track points from scintillator hits
	unsigned int nHitsForThisParticle= fSelScintHitCollection.size();
	//cout<<"TParticleSimData::CreateTrackPoints(): nHitsForThisParticle="<<nHitsForThisParticle<<"  nPlanes="<<nPlanes<<endl;

	//int nStrips= (G4MuonCounterSimulator::GetCurrentMuonDetector())->GetNumberOfStrips();
	//int nPlanes= (G4MuonCounterSimulator::GetCurrentMuonDetector())->GetNumberOfPlanes();

	//## Clear existing collection
	fTrackPointCollection.clear();
	fTrackPointCollection.resize(0);
	
	//## Init vectors
	fStripMultiplicityX.clear();
	fStripMultiplicityX.resize(0);		
	fStripMultiplicityX.assign(unsigned(nPlanes),0);
	fStripMultiplicityY.clear();	
	fStripMultiplicityY.resize(0);
	fStripMultiplicityY.assign(unsigned(nPlanes),0);
	fAverageXHit.clear();
	fAverageXHit.resize(0);
	fAverageXHit.assign(unsigned(nPlanes),0);
	fAverageYHit.clear();
	fAverageYHit.resize(0);
	fAverageYHit.assign(unsigned(nPlanes),0);

	fRX.clear();
	fRX.resize(0);
	fRX.assign(unsigned(nPlanes),0);
	fRY.clear();
	fRY.resize(0);
	fRY.assign(unsigned(nPlanes),0);

	fStripMultiplicity.clear();
	fStripMultiplicity.resize(0);
	

	std::vector< std::vector<double> > xCoordinateList;
	std::vector< std::vector<double> > yCoordinateList;
	for(int m=0;m<nPlanes;m++){
		xCoordinateList.push_back ( std::vector<double>() );
		yCoordinateList.push_back ( std::vector<double>() ); 	
	}
	
	//## First order the hits by superplaneId, planeId, stripId using the absolute stripId
	std::vector<int> AbsStripIdList;
	AbsStripIdList.clear();
	AbsStripIdList.resize(0);
	std::vector<size_t> ordering_index;
	ordering_index.clear();
	ordering_index.resize(0);

	std::vector<int> PlaneList;
	PlaneList.clear();
	PlaneList.resize(0);

	//## Get geom event tag	
	fParticleSimDataGeomTag= GeomEventTagger();
	//cout<<"TParticleSimData::CreateTrackPoints(): fParticleSimDataGeomTag="<<fParticleSimDataGeomTag<<endl;
	
	if(nHitsForThisParticle==0){
		fParticleSimDataTag= eNull;
		return;
	}



	for(unsigned int j=0;j<nHitsForThisParticle;j++) {
		TScintHit currentScintHit= fSelScintHitCollection[j];
		int StripId= currentScintHit.StripId;
		int PlaneId= currentScintHit.PlaneId;
		int SuperPlaneId= currentScintHit.SuperPlaneId;
		int AbsPlaneId= 2*SuperPlaneId+PlaneId;
		int AbsStripId= AbsPlaneId*nStrips+StripId;
		AbsStripIdList.push_back(AbsStripId); 
	}

	Utilities::sort(AbsStripIdList,AbsStripIdList,ordering_index);
	

	//## Combine X-Y hits to form track points	
	//cout<<"# Combined X-Y hits #"<<endl;	
	bool IsMuonXHit= false;
 	bool IsMuonYHit= false;

	for(unsigned int k=0;k<nHitsForThisParticle;k++){//loop over all hits in current event
		TScintHit currentScintHit= fSelScintHitCollection[ordering_index[k]];
		int StripId= currentScintHit.StripId;
		int PlaneId= currentScintHit.PlaneId;
		int SuperPlaneId= currentScintHit.SuperPlaneId;
		int AbsPlaneId= 2*SuperPlaneId+PlaneId;
		int AbsStripId= AbsPlaneId*nStrips+StripId;
		double Edep= currentScintHit.Etot;
		
		//cout<<"TParticleSimData(): INFO: (SP,P,S)=("<<SuperPlaneId<<","<<PlaneId<<","<<StripId<<")  AP="<<AbsPlaneId<<" ==> Edep="<<Edep/CLHEP::MeV<<endl;
		
		//## Loop over all hits to find if this hit is due to a muon
		unsigned int nHitsForThisStrip= (currentScintHit.ParticleType).size();
		IsMuonXHit= false;
		for(unsigned jj=0;jj<nHitsForThisStrip;jj++){
			int hitParticleType= (currentScintHit.ParticleType).at(jj);
			int hitTrackId= (currentScintHit.TrackId).at(jj);
			//cout<<"hitParticleType="<<hitParticleType<<"  hitTrackId="<<hitTrackId<<endl;
			if(hitParticleType==2 && hitTrackId==1){
				IsMuonXHit= true;
				break;		
			}
		}//end search 
		
		//cout<<"Fill list of hit planes"<<endl;
		//## Fill list of hit planes
		//## Fill strip multiplicity list per plane
		//## Fill X and Y positions for each detector planes	
		bool hasHitPlane= false;
		for(unsigned int l=0; l<PlaneList.size();l++){
			if(AbsPlaneId==PlaneList[l]) {
				hasHitPlane= true;
				fStripMultiplicity[l]++;
				if(AbsPlaneId%2==0){
					//X plane --> take y coordinate
					double currentYCoord= (currentScintHit.StripPosition).Y();
					fAverageYHit[SuperPlaneId]+= currentYCoord;
					fStripMultiplicityY[SuperPlaneId]++;
					yCoordinateList[SuperPlaneId].push_back(currentYCoord);
				}
				else{
					//Y plane --> take x coordinate
					double currentXCoord= (currentScintHit.StripPosition).X();
					fAverageXHit[SuperPlaneId]+= currentXCoord;
					fStripMultiplicityX[SuperPlaneId]++;
					xCoordinateList[SuperPlaneId].push_back(currentXCoord);
				}
	
				break;
			}//end if
		}//end loop hit planes
		
		if(!hasHitPlane) {
			PlaneList.push_back(AbsPlaneId);
			fStripMultiplicity.push_back(1);

			if(AbsPlaneId%2==0){
				//X plane --> take y coordinate
				double currentYCoord= (currentScintHit.StripPosition).Y();
				fAverageYHit[SuperPlaneId]= currentYCoord;
				fStripMultiplicityY[SuperPlaneId]= 1;
				
				yCoordinateList[SuperPlaneId].push_back(currentYCoord);
			}
			else{
				//Y plane --> take x coordinate
				double currentXCoord= (currentScintHit.StripPosition).X();
				fAverageXHit[SuperPlaneId]= currentXCoord;
				fStripMultiplicityX[SuperPlaneId]= 1;
				
				xCoordinateList[SuperPlaneId].push_back(currentXCoord);
			}
		}//end if

		//cout<<"Combine X-Y points"<<endl;
		//## Combine X-Y points
		if(AbsPlaneId%2==0){//plane X
			for(unsigned int j=k;j<nHitsForThisParticle;j++){
				TScintHit nextScintHit= fSelScintHitCollection[ordering_index[j]];
				int nextStripId= nextScintHit.StripId;
				int nextPlaneId= nextScintHit.PlaneId;
				int nextSuperPlaneId= nextScintHit.SuperPlaneId;
				int nextAbsPlaneId= 2*nextSuperPlaneId+nextPlaneId;
				int nextAbsStripId= nextAbsPlaneId*nStrips+nextStripId;	
				double nextEdep= nextScintHit.Etot;
				TVector3 nextStripPos= nextScintHit.StripPosition;	

				//## Loop over all hits to find if this hit is due to a muon
				unsigned int nHitsForNextStrip= (nextScintHit.ParticleType).size();
				IsMuonYHit= false;
				for(unsigned jj=0;jj<nHitsForNextStrip;jj++){
					int hitParticleType= (nextScintHit.ParticleType).at(jj);
					int hitTrackId= (nextScintHit.TrackId).at(jj);
					if(hitParticleType==2 && hitTrackId==1){
						IsMuonYHit= true;
						break;		
					}
				}//end search nHitsForNextStrip 
				
				if(nextAbsPlaneId%2==1 && (nextAbsPlaneId-AbsPlaneId)==1) {//select consecutive X-Y planes
					double EdepX= nextScintHit.Etot; 
					double EdepY= currentScintHit.Etot;

					std::vector<double> TimeXVect= nextScintHit.Time;
					double TimeX= *(std::min_element(TimeXVect.begin(),TimeXVect.end()));
					std::vector<double> TimeYVect= currentScintHit.Time;
					double TimeY= *(std::min_element(TimeYVect.begin(),TimeYVect.end()));
		
					TVector3 XPosition= currentScintHit.StripPosition;
					TVector3 YPosition= nextScintHit.StripPosition;
					double XCenter= YPosition.X();
					double YCenter= XPosition.Y();
					double ZCenter= 0.5*(XPosition.Z()+YPosition.Z());

					//## Smear the track points with spatial resolution
					double XSmeared= -999;
					double YSmeared= -999;
					double ZSmeared= -999;
					while(true){
						double xRand= gRandom->Gaus(0,fHitSigmaX);
						//XSmeared= gRandom->Gaus(XCenter,fHitSigmaX);
						XSmeared= XCenter+xRand;
						if(fabs(XSmeared-XCenter)<fHitSigmaX) break;
					}
					while(true){
						double yRand= gRandom->Gaus(0,fHitSigmaY);
						//YSmeared= gRandom->Gaus(YCenter,fHitSigmaY);
						YSmeared= YCenter+yRand;
						if(fabs(YSmeared-YCenter)<fHitSigmaY) break;
					}
					while(true){
						double zRand= gRandom->Gaus(0,fHitSigmaZ);
						//ZSmeared= gRandom->Gaus(ZCenter,fHitSigmaZ);
						ZSmeared= ZCenter+zRand;
						if(fabs(ZSmeared-ZCenter)<fHitSigmaZ) break;
					}	
		
					/*
					cout<<"fHitSigmaX="<<fHitSigmaX<<"  fHitSigmaY="<<fHitSigmaY<<"  fHitSigmaZ="<<fHitSigmaZ<<endl;
					cout<<"XCenter="<<XCenter<<"  YCenter="<<YCenter<<"  ZCenter="<<ZCenter<<endl;
					cout<<"XSmeared="<<XSmeared<<"  YSmeared="<<YSmeared<<"  ZSmeared="<<ZSmeared<<endl;
					cout<<"EdepX="<<EdepX<<"  EdepY="<<EdepY<<endl;
					cout<<"TimeX="<<TimeX<<"  TimeY="<<TimeY<<endl;
					*/

					TVector3 PointPositionAtCenter= TVector3(XCenter, YCenter, ZCenter);
					TVector3 PointPosition= TVector3(XSmeared, YSmeared, ZSmeared);

					TrackPoint aTrackPoint;
					aTrackPoint.fPosition= PointPosition;	
					aTrackPoint.fPositionAtCenter= PointPositionAtCenter;
					aTrackPoint.fDetectorPlaneId= SuperPlaneId;
					aTrackPoint.fEdepX= EdepX;
					aTrackPoint.fEdepY= EdepY;
					aTrackPoint.fTimeX= TimeX;
					aTrackPoint.fTimeY= TimeY;
					//cout<<"IsMuonXHit="<<IsMuonXHit<<"  IsMuonYHit="<<IsMuonYHit<<endl;
					if(IsMuonXHit && IsMuonYHit) aTrackPoint.fIsMuon= 1;
					else aTrackPoint.fIsMuon= 0;
					 
					fTrackPointCollection.push_back(aTrackPoint);					
				}
				else continue;//skip plane X entry or not consecutive X-Y planes
			}//end loop j
		}//close if plane X
		else continue;//skip plane Y entry

	}//end loop k

	/*
	//cout<<"## TRACK POINTS ##"<<endl;
	for(unsigned int k=0;k<fTrackPointCollection.size();k++){
		cout<<"DET PLANE="<<fTrackPointCollection[k].fDetectorPlaneId<<"  Pos=("<<(fTrackPointCollection[k].fPosition).X()<<","<<(fTrackPointCollection[k].fPosition).Y()<<","<<(fTrackPointCollection[k].fPosition).Z()<<")"<<endl;
	}
	*/

	//## Calculate average X and Y positions for each detector planes	
	for(unsigned int m=0;m<fAverageXHit.size();m++){
		if(fStripMultiplicityX[m]!=0) fAverageXHit[m]/= fStripMultiplicityX[m];	
		if(fStripMultiplicityY[m]!=0) fAverageYHit[m]/= fStripMultiplicityY[m];	
		//cout<<"Plane "<<m<<"  MultX="<<fStripMultiplicityX[m]<< "  <X>="<<fAverageXHit[m]<<endl;
		//cout<<"Plane "<<m<<"  MultY="<<fStripMultiplicityY[m]<< "  <Y>="<<fAverageYHit[m]<<endl;
	}

	
	//## Calculate adiacent-strip weight factor r
	for(unsigned int m=0;m<fStripMultiplicityX.size();m++){
		double minX= 0.;
		double maxX= 0.;

		//double minX= *std::min_element(xCoordinateList[m].begin(),xCoordinateList[m].end());
		//double maxX= *std::max_element(xCoordinateList[m].begin(),xCoordinateList[m].end());
		if(xCoordinateList[m].size()>0){
			minX= *std::min_element(xCoordinateList[m].begin(),xCoordinateList[m].end());		 
			maxX= *std::max_element(xCoordinateList[m].begin(),xCoordinateList[m].end());
		}

		double MultiplicityX= fStripMultiplicityX[m];
		double RXWeight= MultiplicityX/( (maxX-minX)/StripSeparation + 1); 
		//cout<<"TParticleSimData::CreateTrackPoints(): RX="<<RXWeight<<"  MultiplicityX="<<MultiplicityX<<" maxX="<<maxX<<"  minX="<<minX<<"  StripSeparation="<<StripSeparation<<endl;
		fRX[m]= RXWeight;
	}//end loop m
	
	for(unsigned int m=0;m<fStripMultiplicityY.size();m++){
		double minY= 0.;
		double maxY= 0.;

		if(yCoordinateList[m].size()>0){
			minY= *std::min_element(yCoordinateList[m].begin(),yCoordinateList[m].end());		 
			maxY= *std::max_element(yCoordinateList[m].begin(),yCoordinateList[m].end());			
		}

		double MultiplicityY= fStripMultiplicityY[m];
		double RYWeight= MultiplicityY/( (maxY-minY)/StripSeparation + 1);
		//cout<<"TParticleSimData::CreateTrackPoints(): RY="<<RYWeight<<"  MultiplicityY="<<MultiplicityY<<" maxY="<<maxY<<"  minX="<<minY<<"  StripSeparation="<<StripSeparation<<endl; 
		fRY[m]= RYWeight;
	}	//end loop m


	//## Tag this particle event
	fParticleSimDataTag= ParticleEventTagger(PlaneList);
	cout<<"TParticleSimData::CreateTrackPoints(): Tag="<<fParticleSimDataTag<<"  GeomTag="<<fParticleSimDataGeomTag<<"  HasGeomCrossedFirstPlane? "<<fHasGeomCrossedFirstPlane<<endl;
	
}//close CreateTrackPoints()


TParticleSimData::ParticleSimEventTag TParticleSimData::ParticleEventTagger(std::vector<int> hitPlaneList){

	TParticleSimData::ParticleSimEventTag thisEventTag;		
	
	//if some plane is present, initially tag as single plane event
	//otherwise return null event tag
	if(hitPlaneList.size()==0) 
		return eNull;
	if(hitPlaneList.size()==1) 
		return eSinglePlane;

	
 
	int planeMultiplicity=0;
		
	/*
	//## WRONG
	int q=0;
	while(q< hitPlaneList.size()){
		//check for X-Y combinations			
		if( (hitPlaneList[q]%2==0) && (hitPlaneList[q+1]%2==1) && (hitPlaneList[q+1]-hitPlaneList[q]==1) ){
			planeMultiplicity++;
      q+= 2;
		}
		else q+= 1;
	}//close while	
	*/
	
	for(unsigned int q=0;q<hitPlaneList.size();q++){
		//Is X plane?
		if(hitPlaneList[q]%2==0){
			for(unsigned int k=q+1;k<hitPlaneList.size();k++){	
				//check for X-Y combinations
				if( (hitPlaneList[k]%2==1) && (hitPlaneList[k]-hitPlaneList[q]==1) ){
					planeMultiplicity++;
					break;	
				}
			}//end loop
		}//end if
	}//end loop


	//Determine event type
	switch(planeMultiplicity){
		case eOneFold:
		{
			thisEventTag= eOneFold;
			break;
		}
		case eTwoFold:
		{
			thisEventTag= eTwoFold;
			break;
		}
		case eThreeFold:
		{
			thisEventTag= eThreeFold;
			break;
		}
		default:
			thisEventTag= eSinglePlane;
			break;	
	}//close switch

	return thisEventTag;

}//close TagEvent()


int TParticleSimData::GeomEventTagger(){

	if(!fDetectorData){
		cerr<<"TParticleSimData::GeomEventTagger(): Detector class has not been initialized...return dummy value!"<<endl;
		return -999;
		//exit(1);
	}

	//## Get particle vertex and direction
	double X0= (this->fPosition).X();
 	double Y0= (this->fPosition).Y();	

	TVector3 dir= TVector3(this->fDirection.X(),this->fDirection.Y(),-this->fDirection.Z());
	double Theta= dir.Theta()* 180./TMath::Pi();
	double Phi= dir.Phi()* 180./TMath::Pi();

	//## Get some detector info
	double XYPlaneDistance= fDetectorData->GetXYPlaneDistance()/CLHEP::m;
	double Xcoat= (fDetectorData->GetStripCoatingSize()).X()/CLHEP::m;
	double Ycoat= (fDetectorData->GetStripCoatingSize()).Y()/CLHEP::m;
	double Zcoat=	(fDetectorData->GetStripCoatingSize()).Z()/CLHEP::m;
	std::vector<double> fSuperPlaneDepth= fDetectorData->GetSuperPlaneDepth();
	//cout<<"TParticleSimData::GeomEventTagger(): XYPlaneDistance="<<XYPlaneDistance<<"  (Xcoat,Ycoat,Zcoat)=("<<Xcoat<<","<<Ycoat<<","<<Zcoat<<")"<<endl;

	//## Calculate hit strips according to particle geometry
  //## HitCoord is y-coordinate for a x-plane and viceversa for a x-plane
  double HitCoord_geom_up= 0.;//hit in superior surface
  double HitCoord_geom_down= 0.;//hit in bottom surface
  double HitCoord_geom_center= 0.;//hit at center of the track

  int HitId_geom_up= -999;
  int HitId_geom_down= -999;
  int HitId_geom_center= -999;   

	std::vector<int> GeomHitStripId;
	GeomHitStripId.clear();
	GeomHitStripId.assign(2*nPlanes,-1);
	
	std::vector<double> PlaneDepth;
	PlaneDepth.clear();
	PlaneDepth.resize(0);
	for(unsigned int i=0;i<fSuperPlaneDepth.size();i++)
		PlaneDepth.push_back(fSuperPlaneDepth[i]/100.);	

  //## Find geometrical intersections track-plane and store strip id 
	//cout<<"GeomEventTagger(): Expected hit strips from geometrical direction"<<endl;
  int n=0;
  for(unsigned int s=0;s<GeomHitStripId.size();s++){
  	
  	if(s%2==0){
    	//x plane (calculate y coord.)
      HitCoord_geom_up= (PlaneDepth[s-n]-Zcoat/2.)*tan(Theta*TMath::Pi()/180.)*sin(Phi*TMath::Pi()/180.) + Y0; 
      HitCoord_geom_down= (PlaneDepth[s-n]+Zcoat/2.)*tan(Theta*TMath::Pi()/180.)*sin(Phi*TMath::Pi()/180.) + Y0; 
			                       
      //check if current track geom intersects more than one strip
      HitId_geom_up= (int)(ceil( (HitCoord_geom_up + Xcoat/2.)/Ycoat ) );        
      HitId_geom_down= (int)(ceil( (HitCoord_geom_down + Xcoat/2.)/Ycoat ) );        
      if(HitId_geom_up == HitId_geom_down){
      	GeomHitStripId[s]= HitId_geom_up;
      }
      else{
      	//find hottest strip according to greater track length        
      	HitCoord_geom_center= (PlaneDepth[s-n])*tan(Theta*TMath::Pi()/180.)*sin(Phi*TMath::Pi()/180.) + Y0; 
        HitId_geom_center= (int)(ceil( (HitCoord_geom_center+Xcoat/2.)/Ycoat ) );
        GeomHitStripId[s]= HitId_geom_center;        
      }
	
			//cout<<"plane "<<s<<" (X):  CoordUp="<<HitCoord_geom_up<<"  CoordDown="<<HitCoord_geom_down<<"  StripIdUp="<<HitId_geom_up<<"  StripIdDown="<<HitId_geom_down<<"  StripId="<<GeomHitStripId[s]<<"  PlaneDepth["<<s-n<<"]="<<PlaneDepth[s-n]<<endl;

    }//close if plane x


    if(s%2==1){
    	//y plane (calculate x coord.)
      HitCoord_geom_up= (PlaneDepth[s-(n+1)]+Zcoat/2.+XYPlaneDistance)*tan(Theta*TMath::Pi()/180.)*cos(Phi*TMath::Pi()/180.) + X0; 
 	    HitCoord_geom_down= (PlaneDepth[s-(n+1)]+1.5*Zcoat+XYPlaneDistance)*tan(Theta*TMath::Pi()/180.)*cos(Phi*TMath::Pi()/180.) + X0; 
                        
     	//check if current track geom intersects more than one strip
      HitId_geom_up= (int)(ceil( (HitCoord_geom_up+Xcoat/2.)/Ycoat ) );        
      HitId_geom_down= (int)(ceil( (HitCoord_geom_down+Xcoat/2.)/Ycoat ) );        
      if(HitId_geom_up==HitId_geom_down){
      	GeomHitStripId[s]= HitId_geom_up;
      }
      else{
      	//find hottest strip according to greater track length        
       	HitCoord_geom_center= (PlaneDepth[s-(n+1)]+Zcoat+XYPlaneDistance)*tan(Theta*TMath::Pi()/180.)*cos(Phi*TMath::Pi()/180.) + X0; 
        HitId_geom_center= (int)(ceil( (HitCoord_geom_center+Xcoat/2.)/Ycoat ) );
        GeomHitStripId[s]= HitId_geom_center;
      }

			//cout<<"plane "<<s<<" (Y):  CoordUp="<<HitCoord_geom_up<<"  CoordDown="<<HitCoord_geom_down<<"  StripIdUp="<<HitId_geom_up<<"  StripIdDown="<<HitId_geom_down<<"  StripId="<<GeomHitStripId[s]<<"  PlaneDepth["<<s-(n+1)<<"]="<<PlaneDepth[s-(n+1)]<<endl;

      n++;
    }//close plane y

    //cout<<"Plane="<<s<<"  StripNo="<< GeomHitStripId[s] << "  coord="<<HitCoord_geom_up<<endl;     
		
	}//close plane s loop
	//cout<<endl;

	//## Loop over geometrical hit strip, check if they exists 
	//## Assign the IsInsideAcceptance flag
	
	int foldCounter= 0;
	fHasGeomCrossedFirstPlane= 0;
	for(unsigned int s=0;s<GeomHitStripId.size();s+=2){
		if(GeomHitStripId[s]>=1 && GeomHitStripId[s]<=nStrips && 
			 GeomHitStripId[s+1]>=1 && GeomHitStripId[s+1]<=nStrips
		){
			foldCounter++;
			if(s==0) fHasGeomCrossedFirstPlane= 1;
		}			
	}//end loop geom hit strips
	
	int FOVTag= foldCounter;
	
 	return FOVTag;

}//close TParticleSimData::GeomEventTagger()



void TParticleSimData::AddMuonCount(std::vector<double> counts, std::string dir){

	
	unsigned int size= counts.size();

	if(dir.compare(std::string("in")) == 0){
		if(fMuonNumber.empty()){
			fMuonNumber.clear();
			fMuonNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fMuonNumber.size();i++)
			fMuonNumber[i]+= counts[i];
	}//end if incoming counts
	else if(dir.compare(std::string("out")) == 0){
		if(fMuonAlbedoNumber.empty()){
			fMuonAlbedoNumber.clear();
			fMuonAlbedoNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fMuonAlbedoNumber.size();i++)
			fMuonAlbedoNumber[i]+= counts[i];
	}
	else{
		cerr<<"TParticleSimData::AddMuonCount(): Invalid direction option..exit"<<endl; 
		exit(1);
	}

}//close AddMuonCount()


void TParticleSimData::AddEmCount(std::vector<double> counts, std::string dir){

	unsigned int size= counts.size();
	
	if(dir.compare(std::string("in")) == 0){
		if(fEmNumber.empty()){
			fEmNumber.clear();
			fEmNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fEmNumber.size();i++)
			fEmNumber[i]+= counts[i];
	}//end if incoming counts
	else if(dir.compare(std::string("out")) == 0){
		if(fEmAlbedoNumber.empty()){
			fEmAlbedoNumber.clear();
			fEmAlbedoNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fEmAlbedoNumber.size();i++)
			fEmAlbedoNumber[i]+= counts[i];
	}
	else{
		cerr<<"TParticleSimData::AddEmCount(): Invalid direction option..exit"<<endl; 
		exit(1);
	}

	
}//close AddMuonCount()


void TParticleSimData::AddHadronCount(std::vector<double> counts, std::string dir){

	
	unsigned int size= counts.size();
	
	if(dir.compare(std::string("in")) == 0){
		if(fHadronNumber.empty()){
			fHadronNumber.clear();
			fHadronNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fHadronNumber.size();i++)
			fHadronNumber[i]+= counts[i];

		//cout<<"AddHadronCount dir="<<dir<<"  size="<<size<<"  vect size="<<fHadronNumber.size()<<endl;

	}//end if incoming counts
	else if(dir.compare(std::string("out")) == 0){
		if(fHadronAlbedoNumber.empty()){
			fHadronAlbedoNumber.clear();
			fHadronAlbedoNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fHadronAlbedoNumber.size();i++)
			fHadronAlbedoNumber[i]+= counts[i];

		//cout<<"AddHadronCount dir="<<dir<<"  size="<<size<<"  vect size="<<fHadronAlbedoNumber.size()<<endl;

	}
	else{
		cerr<<"TParticleSimData::AddHadronCount(): Invalid direction option..exit"<<endl; 
		exit(1);
	}

	

}//close AddHadronCount()



ClassImp(TParticleSimData)

#ifdef __MAKECINT__
#pragma link C++ class TParticleSimData+; 
#endif

#ifdef __MAKECINT__
#pragma link C++ class std::vector<TParticleSimData*>+;
#endif

#ifdef __MAKECINT__
#pragma link C++ class std::vector<TParticleSimData>+;
#endif

