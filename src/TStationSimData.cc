/**
* @file TStationSimData.cc
* @class TStationSimData
* @brief Define the sim data structure for each muon counter station for the output ROOT file
*
* A ROOT dictionary for this class is generated by the Makefile
* @author Simone Riggi
* @date 22/12/2010
*/

#include <TStationSimData.hh>
#include <TScintHit.hh>
#include <TPMTHit.hh>
#include <PMTSimulator.hh>
#include <G4MuonCounterSimulator.hh>
#include <G4MuonCounterConstruction.hh>
#include <Utilities.hh>

#include <TVector3.h>
#include <TRandom.h>
#include <TRandom3.h>

#include <stdio.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <vector>
#include <string>
#include <stdexcept>
#include <algorithm>


using namespace G4MuonCounterSimulatorUSC;

TStationSimData::TStationSimData()
: fId(-1)
{

	fPosition(0);

	fScintHitCollection.clear();
	fScintHitCollection.resize(0);

	fSelScintHitCollection.clear();
	fSelScintHitCollection.resize(0);

	fScintHitCollectionInTimeBin.clear();	
	fScintHitCollectionInTimeBin.resize(0);

	fPMTHitCollection.clear();
	fPMTHitCollection.resize(0);

	fParticleSimDataCollection.clear();
	fParticleSimDataCollection.resize(0);

	fParticleSimDataCollectionInTimeBin.clear();
	fParticleSimDataCollectionInTimeBin.resize(0);

	fListOfHitAbsStripId.clear();
	fListOfHitAbsStripId.resize(0);

	fSelListOfHitAbsStripId.clear();
	fSelListOfHitAbsStripId.resize(0);

/*
	fMuonNumber.clear();
	fMuonNumber.assign(10,0);

	fEmNumber.clear();
	fEmNumber.assign(10,0);
*/
  
}//close constructor

TStationSimData::~TStationSimData(){

}//close destructor


bool TStationSimData::HasScintHit(TScintHit hit, HitSearchMode whereToSearch, int& collectionIndex){

	bool isStripInCollection= false;
	collectionIndex= -1;


	//summary info for this hit
	int StripId= hit.StripId;
	int PlaneId= hit.PlaneId;
	int SuperPlaneId= hit.SuperPlaneId;
	int AbsPlaneId= 2*SuperPlaneId+PlaneId;
	int AbsStripId= AbsPlaneId*nStrips+StripId;
	//cout<<"TStationSimData::HasScintHit(): INFO: (SP,P,S)=("<<SuperPlaneId<<","<<PlaneId<<","<<StripId<<")  AP="<<AbsPlaneId<<"  AS="<<AbsStripId<<endl;

	//## Faster (?) search in collection
	//which collection to search in?
	std::vector<int> hitIdCollection;
	if(whereToSearch == eInFullCollection)
		hitIdCollection= fListOfHitAbsStripId; 
	else if(whereToSearch == eInSelectionCollection)
		hitIdCollection= fSelListOfHitAbsStripId;
	else{
		cerr<<"TStationSimData::HasScintHit(): Invalid search given"<<endl;
		exit(1); 
	}

	//search first if the hit strip has been already stored in the collection 
	//cout<<"TStationSimData::HasScintHit(): searching in hit collection of size "<<hitIdCollection.size()<<endl;

	std::vector<int>::const_iterator it= std::find(hitIdCollection.begin(), hitIdCollection.end(), AbsStripId);

	if(it == hitIdCollection.end())
		return false;


	collectionIndex= it-hitIdCollection.begin();
	isStripInCollection= true;

	/*
	//which collection to search in?
	std::vector<TScintHit> hitCollection;
	if(whereToSearch == eInFullCollection)
		hitCollection= fScintHitCollection; 
	else if(whereToSearch == eInSelectionCollection)
		hitCollection= fSelScintHitCollection;
	else{
		cerr<<"TStationSimData::HasScintHit(): Invalid search given"<<endl;
		exit(1); 
	}

	//search first if the hit strip has been already stored in the collection 
	cout<<"TStationSimData::HasScintHit(): searching in hit collection of size "<<hitCollection.size()<<endl;
	for(unsigned i=0;i<hitCollection.size();i++){
		TScintHit currentStationScintHit= hitCollection[i];
		int StationStripId= currentStationScintHit.StripId;
		int StationPlaneId= currentStationScintHit.PlaneId;
		int StationSuperPlaneId= currentStationScintHit.SuperPlaneId;
				
		if(StationStripId== StripId && StationPlaneId== PlaneId && StationSuperPlaneId== SuperPlaneId){
			//hit strip already stored in vector for this station
			isStripInCollection= true;
			collectionIndex= i;
			break;
		}	
	}//end search loop station strip hits
	*/
	

	return isStripInCollection;

}//close HasScintHit()

bool TStationSimData::AddScintHit(TScintHit hit, HitSearchMode whereToAdd){

	//## CPU time counters
	clock_t start, finish;
	double searchHitCPUTimeSpent= 0;
	double addHitCPUTimeSpent= 0;

	//search given hit
	int collectionIndex;
	start = std::clock();
	bool isStripInCollection= HasScintHit(hit,whereToAdd,collectionIndex);
	finish = std::clock();
	searchHitCPUTimeSpent = (double)(finish - start) / CLOCKS_PER_SEC;

	//which collection to add to?
	std::vector<TScintHit> hitCollection;
	if(whereToAdd == eInFullCollection)
		hitCollection= fScintHitCollection; 
	else if(whereToAdd == eInSelectionCollection)
		hitCollection= fSelScintHitCollection;
	else{
		cerr<<"TStationSimData::AddScintHit(): Invalid search given"<<endl;
		exit(1); 
	}
	
	//if the hit strip is not present just add it
	if(!isStripInCollection){	
		hitCollection.push_back(hit);

		int StripId= hit.StripId;
		int PlaneId= hit.PlaneId;
		int SuperPlaneId= hit.SuperPlaneId;
		int AbsPlaneId= 2*SuperPlaneId+PlaneId;
		int AbsStripId= AbsPlaneId*nStrips+StripId;
		
		if(whereToAdd == eInFullCollection){
			fScintHitCollection= hitCollection;
			fListOfHitAbsStripId.push_back(AbsStripId);
		} 
		else if(whereToAdd == eInSelectionCollection){
			fSelScintHitCollection= hitCollection;
			fSelListOfHitAbsStripId.push_back(AbsStripId);
		}

		//cout<<"*** TStationSimData::AddScintHit() ***"<<endl;
		//cout<<"searchHitCPUTimeSpent: "<< searchHitCPUTimeSpent<<" s"<<endl;
		//cout<<"addHitCPUTimeSpent: "<< addHitCPUTimeSpent<<" s"<<endl;
		//cout<<"**************************************"<<endl;

		return true;
	}

	
	//otherwise append to the existing strip hit
	start = std::clock();

	unsigned int nHitsForThisStrip= (hit.Edep).size();
	unsigned int nPMTForThisStrip= (hit.ExpPMTTime).size();
	for(unsigned int j=0;j<nHitsForThisStrip;j++){	
		double Edep= hit.Edep[j];
		double Time= hit.Time[j];			
		int TrackId= hit.TrackId[j];
		int ParticleType= hit.ParticleType[j];
		TVector3 Position= hit.Position[j];	
		TVector3 TrackDirection= hit.TrackDirection[j];

		//add to existing collection
		(hitCollection[collectionIndex].Edep).push_back(Edep);
		(hitCollection[collectionIndex].Time).push_back(Time);
		(hitCollection[collectionIndex].TrackId).push_back(TrackId);
		(hitCollection[collectionIndex].ParticleType).push_back(ParticleType);
		(hitCollection[collectionIndex].Position).push_back(Position);
		(hitCollection[collectionIndex].TrackDirection).push_back(TrackDirection);
				
		(hitCollection[collectionIndex].Etot)+= Edep;	

		for(unsigned int k=0;k<nPMTForThisStrip;k++) {
			double expPMTTime= hit.ExpPMTTime[k][j];
			(hitCollection[collectionIndex].ExpPMTTime[k]).push_back(expPMTTime);
		}


	}//end loop hits for this strip

	unsigned int nPhotonsForThisStrip= (hit.PhotonTrackLength).size();
	for(unsigned int j=0;j<nPhotonsForThisStrip;j++){
		double PhotonTrackLength= hit.PhotonTrackLength[j];
		double PhotonTrackDistance= hit.PhotonTrackDistance[j];
		double PhotonEmissionAngle= hit.PhotonEmissionAngle[j];
		double PhotonEmissionTime= hit.PhotonEmissionTime[j];
		double PhotonEmissionWavelength= hit.PhotonEmissionWavelength[j];
		int PhotonProcessType= hit.PhotonProcessType[j];

		//add to existing collection
		(hitCollection[collectionIndex].PhotonTrackLength).push_back(PhotonTrackLength);
		(hitCollection[collectionIndex].PhotonTrackDistance).push_back(PhotonTrackDistance);	
		(hitCollection[collectionIndex].PhotonEmissionAngle).push_back(PhotonEmissionAngle);
		(hitCollection[collectionIndex].PhotonEmissionTime).push_back(PhotonEmissionTime);
		(hitCollection[collectionIndex].PhotonEmissionWavelength).push_back(PhotonEmissionWavelength);
		(hitCollection[collectionIndex].PhotonProcessType).push_back(PhotonProcessType);
	}//end loop photons for this strip


	//## Re-copy values to right collection
	if(whereToAdd == eInFullCollection)
		fScintHitCollection= hitCollection; 
	else if(whereToAdd == eInSelectionCollection)
		fSelScintHitCollection= hitCollection;

	finish = std::clock();
	addHitCPUTimeSpent = (double)(finish - start) / CLOCKS_PER_SEC;


	//cout<<"*** TStationSimData::AddScintHit() ***"<<endl;
	//cout<<"searchHitCPUTimeSpent: "<< searchHitCPUTimeSpent<<" s"<<endl;
	//cout<<"addHitCPUTimeSpent: "<< addHitCPUTimeSpent<<" s"<<endl;
	//cout<<"**************************************"<<endl;

	return true;

}//close TStationSimData::AddScintHit()



bool TStationSimData::SelectScintHit(TScintHit hit,TScintHit& selHit){
	
	//## select the given hit according to the selection conditions
	//search given hit
	int collectionIndex;
	bool isStripInCollection= HasScintHit(hit,eInSelectionCollection,collectionIndex);
	//cout<<endl;
	//cout<<"TStationSimData::SelectScintHit: is this strip present in selection collection? "<<isStripInCollection<<endl;

	//summary info for this hit
	int StripId= hit.StripId;
	int PlaneId= hit.PlaneId;
	int SuperPlaneId= hit.SuperPlaneId;
	int AbsPlaneId= 2*SuperPlaneId+PlaneId;
	int AbsStripId= AbsPlaneId*nStrips+StripId;
	
	double Etot= hit.Etot;
	TVector3 StripPosition= hit.StripPosition;
	std::vector<TVector3> PhotocathodeSurfPosList= hit.PhotocathodeSurfacePosition;
	
	//select and fill hit
	selHit.StripId= StripId;
	selHit.PlaneId= PlaneId;	
	selHit.SuperPlaneId= SuperPlaneId;	
	selHit.StripPosition= StripPosition;
	selHit.PhotocathodeSurfacePosition= PhotocathodeSurfPosList;	
	
	double nHitTimeEntries= 0;
	double lastHitTime= -9.e+99;//fake value to accept first hit if the strip is not present in the collection
	
	
	unsigned int nHitsForThisStrip= (hit.Edep).size();

	/*	
	unsigned int nPMT= PhotocathodeSurfPosList.size();
	double ExpPMTTimeHit[nPMT][nHitsForThisStrip];	
	//generate time @ PMT cathode
	for(unsigned int j=0;j<nHitsForThisStrip;j++){	
		TVector3 Position= hit.Position[j];
		double Time= hit.Time[j];			
			
		//loop over all PMTs for this strip
		for(unsigned int k=0;k<PhotocathodeSurfPosList.size();k++){
			TVector3 PhotocathodeSurfPosition= PhotocathodeSurfPosList[k];
			TVector3 HitPMTDistance= PhotocathodeSurfPosition-Position;
			double HitPMTHorizontalDistance= 0.;

			if(AbsPlaneId%2==0){//X plane: take distance in x
				HitPMTHorizontalDistance= fabs(HitPMTDistance.X());
			}
			else if(AbsPlaneId%2==1){//Y plane: take distance in y
				HitPMTHorizontalDistance= fabs(HitPMTDistance.Y());
			}

			PMTSimulator* fPMTSimulator= new PMTSimulator();
			fPMTSimulator->SetTransitTime(G4MuonCounterConstruction::GetPMTTransitTimeAverage());
			fPMTSimulator->SetTransitTimeSpread(G4MuonCounterConstruction::GetPMTTransitTimeSpread());
			fPMTSimulator->SetScintillatorDecayTime(G4MuonCounterConstruction::GetStripDecayTime());
			fPMTSimulator->SetFiberDecayTime(G4MuonCounterConstruction::GetFiberDecayTime());
			fPMTSimulator->SetFiberCriticalAngle(G4MuonCounterConstruction::GetFiberCriticalAngle());
			fPMTSimulator->SetFiberCoreRefractiveIndex(G4MuonCounterConstruction::GetFiberCoreRefractiveIndex());
			fPMTSimulator->SetPhotoelectronYield(G4MuonCounterConstruction::GetPMTPhotoelectronYield()); 
			double expPMTHitTime= Time +
													  fPMTSimulator->GeneratePETime(HitPMTHorizontalDistance);
			cout<<"Generated PMTExpTime pmt "<<k+1<<"  ="<<expPMTHitTime<<endl;
			ExpPMTTimeHit[k][j]= expPMTHitTime;
			delete fPMTSimulator;

		}//end loop PMTs
	}//end loop hits
	*/

	//order hit time entries 
	std::vector<double> hitTimeList;
	hitTimeList.clear();
	hitTimeList.resize(0);
	std::vector<size_t> ordering_index;
	for(unsigned int j=0;j<nHitsForThisStrip;j++) 
		hitTimeList.push_back(hit.Time[j]); 

	Utilities::sort(hitTimeList,hitTimeList,ordering_index);


	//select hits
	for(unsigned int j=0;j<nHitsForThisStrip;j++){	
		double Edep= hit.Edep[ordering_index[j]];
		double Time= hit.Time[ordering_index[j]];			
		int TrackId= hit.TrackId[ordering_index[j]];
		int ParticleType= hit.ParticleType[ordering_index[j]];
		TVector3 Position= hit.Position[ordering_index[j]];
		TVector3 TrackDirection= hit.TrackDirection[ordering_index[j]];	

		//get time of last hit in this strip	
		if(isStripInCollection) {
			nHitTimeEntries= (fSelScintHitCollection[collectionIndex].Time).size();
			lastHitTime= (fSelScintHitCollection[collectionIndex].Time)[nHitTimeEntries-1];
		}

		//apply selection
		cout<<"TStationSimData(): INFO: TrackId="<<TrackId<<"  (SP,P,S)=("<<SuperPlaneId<<","<<PlaneId<<","<<StripId<<")  AP="<<AbsPlaneId<<"  AS="<<AbsStripId<<"  ==> Edep="<<Edep<<"  Time="<<Time<<"  DeltaTime="<<Time-lastHitTime<<endl; 	

		if(Edep<G4MuonCounterConstruction::GetStripEnergyThreshold()) {
			cout<<"TStationSimData(): INFO: Edep ("<<Edep<<") below threshold ("<<G4MuonCounterConstruction::GetStripEnergyThreshold()<<")...skip hit!"<<endl; 			
			continue; //below energy threshold...skip this hit
		}
		if((Time-lastHitTime)<G4MuonCounterConstruction::GetStripVetoTime()) {
			cout<<"TStationSimData(): INFO: DeltaT ("<<Time-lastHitTime<<") within veto tollerance ("<<G4MuonCounterConstruction::GetStripVetoTime()<<")...skip hit!"<<endl; 
			continue; //within veto time...skip this hit
		}

		//if this hit is selected, store last hit time
		lastHitTime= Time;

		//add for new hit
		(selHit.Edep).push_back(Edep);
		(selHit.Time).push_back(Time);
		(selHit.TrackId).push_back(TrackId);
		(selHit.ParticleType).push_back(ParticleType);
		(selHit.Position).push_back(Position);
		(selHit.TrackDirection).push_back(TrackDirection);
				
		(selHit.Etot)+= Edep;	
	}//end loop hits for this strip

	unsigned int nPhotonsForThisStrip= (hit.PhotonTrackLength).size();
	for(unsigned int j=0;j<nPhotonsForThisStrip;j++){
		double PhotonTrackLength= hit.PhotonTrackLength[j];
		double PhotonTrackDistance= hit.PhotonTrackDistance[j];
		double PhotonEmissionAngle= hit.PhotonEmissionAngle[j];
		double PhotonEmissionTime= hit.PhotonEmissionTime[j];
		double PhotonEmissionWavelength= hit.PhotonEmissionWavelength[j];
		double PhotonProcessType= hit.PhotonProcessType[j];

		//add for new hit
		(selHit.PhotonTrackLength).push_back(PhotonTrackLength);
		(selHit.PhotonTrackDistance).push_back(PhotonTrackDistance);	
		(selHit.PhotonEmissionAngle).push_back(PhotonEmissionAngle);
		(selHit.PhotonEmissionTime).push_back(PhotonEmissionTime);
		(selHit.PhotonEmissionWavelength).push_back(PhotonEmissionWavelength);
		(selHit.PhotonProcessType).push_back(PhotonProcessType);
	}//end loop photons for this strip

	double finalTotEnergyDep= selHit.Etot;
	if(finalTotEnergyDep<=0) 
		return false;
	
	return true;

}//close SelectStripHit()



void TStationSimData::CreateTrackPoints(){

	//## Create collection of track points from scintillator hits
	unsigned int nHitsForThisStation= fScintHitCollectionInTimeBin.size();
	//cout<<"nHitsForThisStation="<<nHitsForThisStation<<"  nPlanes="<<nPlanes<<endl;

	//## Clear existing collection
	fTrackPointCollection.clear();
	fTrackPointCollection.resize(0);


	//## Init vectors
	fStripMultiplicityX.clear();
	fStripMultiplicityX.resize(0);		
	fStripMultiplicityX.assign(unsigned(nPlanes),0);
	fStripMultiplicityY.clear();	
	fStripMultiplicityY.resize(0);
	fStripMultiplicityY.assign(unsigned(nPlanes),0);
	fAverageXHit.clear();
	fAverageXHit.resize(0);
	fAverageXHit.assign(unsigned(nPlanes),0);
	fAverageYHit.clear();
	fAverageYHit.resize(0);
	fAverageYHit.assign(unsigned(nPlanes),0);

	fRX.clear();
	fRX.resize(0);
	fRX.assign(unsigned(nPlanes),0);
	fRY.clear();
	fRY.resize(0);
	fRY.assign(unsigned(nPlanes),0);

	fStripMultiplicity.clear();
	fStripMultiplicity.resize(0);

	std::vector< std::vector<double> > xCoordinateList;
	std::vector< std::vector<double> > yCoordinateList;
	for(int m=0;m<nPlanes;m++){
		xCoordinateList.push_back ( std::vector<double>() );
		yCoordinateList.push_back ( std::vector<double>() ); 	
	}


	//## First order the hits by superplaneId, planeId, stripId using the absolute stripId
	std::vector<int> AbsStripIdList;
	AbsStripIdList.clear();
	AbsStripIdList.resize(0);
	std::vector<size_t> ordering_index;
	ordering_index.clear();
	ordering_index.resize(0);

	std::vector<int> PlaneList;
	PlaneList.clear();
	PlaneList.resize(0);

	
	if(nHitsForThisStation>0){


	for(unsigned int j=0;j<nHitsForThisStation;j++) {
		TScintHit currentScintHit= fScintHitCollectionInTimeBin[j];
		int StripId= currentScintHit.StripId;
		int PlaneId= currentScintHit.PlaneId;
		int SuperPlaneId= currentScintHit.SuperPlaneId;
		int AbsPlaneId= 2*SuperPlaneId+PlaneId;
		int AbsStripId= AbsPlaneId*nStrips+StripId;
		AbsStripIdList.push_back(AbsStripId); 
	}

	Utilities::sort(AbsStripIdList,AbsStripIdList,ordering_index);

	

	//## Combine X-Y hits to form track points	
	//cout<<"# Combined X-Y hits #"<<endl;	
	bool IsMuonXHit= false;
 	bool IsMuonYHit= false;

	for(unsigned int k=0;k<nHitsForThisStation;k++){//loop over all hits in current event
		TScintHit currentScintHit= fScintHitCollectionInTimeBin[ordering_index[k]];
		int StripId= currentScintHit.StripId;
		int PlaneId= currentScintHit.PlaneId;
		int SuperPlaneId= currentScintHit.SuperPlaneId;
		int AbsPlaneId= 2*SuperPlaneId+PlaneId;
		int AbsStripId= AbsPlaneId*nStrips+StripId;
		double Edep= currentScintHit.Etot;
		
		//cout<<"(SP,P,S)=("<<SuperPlaneId<<","<<PlaneId<<","<<StripId<<")  AP="<<AbsPlaneId<<"  X="<<(currentScintHit.StripPosition).X()<<"  Y="<<(currentScintHit.StripPosition).Y()<<endl;
		
		//## Loop over all hits to find if this hit is due to a muon
		unsigned int nHitsForThisStrip= (currentScintHit.ParticleType).size();
		IsMuonXHit= false;
		for(unsigned jj=0;jj<nHitsForThisStrip;jj++){
			int hitParticleType= (currentScintHit.ParticleType).at(jj);
			int hitTrackId= (currentScintHit.TrackId).at(jj);
			//cout<<"hitParticleType="<<hitParticleType<<"  hitTrackId="<<hitTrackId<<endl;
			if(hitParticleType==2 && hitTrackId==1){
				IsMuonXHit= true;
				break;		
			}
		}//end search 
		
		//cout<<"Fill list of hit planes"<<endl;
		//## Fill list of hit planes
		//## Fill strip multiplicity list per plane
		//## Fill X and Y positions for each detector planes	
		bool hasHitPlane= false;
		for(unsigned int l=0; l<PlaneList.size();l++){
			if(AbsPlaneId==PlaneList[l]) {
				hasHitPlane= true;
				fStripMultiplicity[l]++;
				if(AbsPlaneId%2==0){
					//X plane --> take y coordinate
					double currentYCoord= (currentScintHit.StripPosition).Y();
					fAverageYHit[SuperPlaneId]+= currentYCoord;
					fStripMultiplicityY[SuperPlaneId]++;
					yCoordinateList[SuperPlaneId].push_back(currentYCoord);
				}
				else{
					//Y plane --> take x coordinate
					double currentXCoord= (currentScintHit.StripPosition).X();
					fAverageXHit[SuperPlaneId]+= currentXCoord;
					fStripMultiplicityX[SuperPlaneId]++;
					xCoordinateList[SuperPlaneId].push_back(currentXCoord);
				}
	
				break;
			}//end if
		}//end loop hit planes
		//cout<<"end loop hit planes"<<endl;

		if(!hasHitPlane) {
			PlaneList.push_back(AbsPlaneId);
			fStripMultiplicity.push_back(1);

			if(AbsPlaneId%2==0){
				//X plane --> take y coordinate
				double currentYCoord= (currentScintHit.StripPosition).Y();
				fAverageYHit[SuperPlaneId]= currentYCoord;
				fStripMultiplicityY[SuperPlaneId]= 1;
				
				yCoordinateList[SuperPlaneId].push_back(currentYCoord);
			}
			else{
				//Y plane --> take x coordinate
				double currentXCoord= (currentScintHit.StripPosition).X();
				fAverageXHit[SuperPlaneId]= currentXCoord;
				fStripMultiplicityX[SuperPlaneId]= 1;
				
				xCoordinateList[SuperPlaneId].push_back(currentXCoord);
			}
		}//end if

		//cout<<"Combine X-Y points"<<endl;
		//## Combine X-Y points
		if(AbsPlaneId%2==0){//plane X
			for(unsigned int j=k;j<nHitsForThisStation;j++){
				TScintHit nextScintHit= fScintHitCollectionInTimeBin[ordering_index[j]];
				int nextStripId= nextScintHit.StripId;
				int nextPlaneId= nextScintHit.PlaneId;
				int nextSuperPlaneId= nextScintHit.SuperPlaneId;
				int nextAbsPlaneId= 2*nextSuperPlaneId+nextPlaneId;
				int nextAbsStripId= nextAbsPlaneId*nStrips+nextStripId;	
				double nextEdep= nextScintHit.Etot;
				TVector3 nextStripPos= nextScintHit.StripPosition;	

				//## Loop over all hits to find if this hit is due to a muon
				unsigned int nHitsForNextStrip= (nextScintHit.ParticleType).size();
				IsMuonYHit= false;
				for(unsigned jj=0;jj<nHitsForNextStrip;jj++){
					int hitParticleType= (nextScintHit.ParticleType).at(jj);
					int hitTrackId= (nextScintHit.TrackId).at(jj);
					if(hitParticleType==2 && hitTrackId==1){
						IsMuonYHit= true;
						break;		
					}
				}//end search 
				

				if(nextAbsPlaneId%2==1 && (nextAbsPlaneId-AbsPlaneId)==1) {//select consecutive X-Y planes
					double EdepX= nextScintHit.Etot; 
					double EdepY= currentScintHit.Etot;

					std::vector<double> TimeXVect= nextScintHit.Time;
					double TimeX= *(std::min_element(TimeXVect.begin(),TimeXVect.end()));
					std::vector<double> TimeYVect= currentScintHit.Time;
					double TimeY= *(std::min_element(TimeYVect.begin(),TimeYVect.end()));
		
					TVector3 XPosition= currentScintHit.StripPosition;
					TVector3 YPosition= nextScintHit.StripPosition;
					double XCenter= YPosition.X();
					double YCenter= XPosition.Y();
					double ZCenter= 0.5*(XPosition.Z()+YPosition.Z());

					//## Smear the track points with spatial resolution
					double XSmeared, YSmeared, ZSmeared;
					while(true){
						double xRand= gRandom->Gaus(0,fHitSigmaX);
						XSmeared= XCenter+xRand;
						if(fabs(XSmeared-XCenter)<fHitSigmaX) break;
					}
					while(true){
						double yRand= gRandom->Gaus(0,fHitSigmaY);
						YSmeared= YCenter+yRand;
						if(fabs(YSmeared-YCenter)<fHitSigmaY) break;
					}
					while(true){
						double zRand= gRandom->Gaus(0,fHitSigmaZ);
						ZSmeared= ZCenter+zRand;
						if(fabs(ZSmeared-ZCenter)<fHitSigmaZ) break;
					}	
		
					/*
					cout<<"fHitSigmaX="<<fHitSigmaX<<"  fHitSigmaY="<<fHitSigmaY<<"  fHitSigmaZ="<<fHitSigmaZ<<endl;
					cout<<"XCenter="<<XCenter<<"  YCenter="<<YCenter<<"  ZCenter="<<ZCenter<<endl;
					cout<<"XSmeared="<<XSmeared<<"  YSmeared="<<YSmeared<<"  ZSmeared="<<ZSmeared<<endl;
					cout<<"EdepX="<<EdepX<<"  EdepY="<<EdepY<<endl;
					cout<<"TimeX="<<TimeX<<"  TimeY="<<TimeY<<endl;
					*/

					TVector3 PointPositionAtCenter= TVector3(XCenter, YCenter, ZCenter);
					TVector3 PointPosition= TVector3(XSmeared, YSmeared, ZSmeared);

					TrackPoint aTrackPoint;
					aTrackPoint.fPosition= PointPosition;	
					aTrackPoint.fPositionAtCenter= PointPositionAtCenter;
					aTrackPoint.fDetectorPlaneId= SuperPlaneId;
					aTrackPoint.fEdepX= EdepX;
					aTrackPoint.fEdepY= EdepY;
					aTrackPoint.fTimeX= TimeX;
					aTrackPoint.fTimeY= TimeY;
					if(IsMuonXHit && IsMuonYHit) aTrackPoint.fIsMuon= 1;
					else aTrackPoint.fIsMuon= 0;
					 
					fTrackPointCollection.push_back(aTrackPoint);					
				}
				else continue;//skip plane X entry or not consecutive X-Y planes
			}//end loop j
		}//close if plane X
		else continue;//skip plane Y entry

	}//end loop k

	
	//## Calculate average X and Y positions for each detector planes	
	for(unsigned int m=0;m<fAverageXHit.size();m++){
		if(fStripMultiplicityX[m]!=0) fAverageXHit[m]/= fStripMultiplicityX[m];	
		if(fStripMultiplicityY[m]!=0) fAverageYHit[m]/= fStripMultiplicityY[m];	
	}

	
	//## Calculate adiacent-strip weight factor r
	for(unsigned int m=0;m<fStripMultiplicityX.size();m++){
		double minX= 0.;
		double maxX= 0.;

		if(xCoordinateList[m].size()>0){
			minX= *std::min_element(xCoordinateList[m].begin(),xCoordinateList[m].end());		 
			maxX= *std::max_element(xCoordinateList[m].begin(),xCoordinateList[m].end());
		}

		double MultiplicityX= fStripMultiplicityX[m];
		double RXWeight= MultiplicityX/(maxX-minX+1); 
		fRX[m]= RXWeight;
	}
	
	for(unsigned int m=0;m<fStripMultiplicityY.size();m++){
		double minY= 0.;
		double maxY= 0.;

		if(yCoordinateList[m].size()>0){
			minY= *std::min_element(yCoordinateList[m].begin(),yCoordinateList[m].end());		 
			maxY= *std::max_element(yCoordinateList[m].begin(),yCoordinateList[m].end());			
		}

		double MultiplicityY= fStripMultiplicityY[m];
		double RYWeight= MultiplicityY/(maxY-minY+1); 
		fRY[m]= RYWeight;
	}	

	}//close if nHitsForThisStation
	

	//## Tag this particle event 
	fStationSimDataTag= StationEventTagger(PlaneList);
	//cout<<"StationSimDataTag --> "<<fStationSimDataTag<<endl;
	//cout<<endl;

}//close CreateTrackPoints()


TStationSimData::StationSimEventTag TStationSimData::StationEventTagger(std::vector<int> hitPlaneList){

	TStationSimData::StationSimEventTag thisEventTag;		
	
	//if some plane is present, initially tag as single plane event
	//otherwise return null event tag
	if(hitPlaneList.size()==0) 
		return eNull;
	if(hitPlaneList.size()==1) 
		return eSinglePlane;

	
 
	int planeMultiplicity=0;
		
	
	for(unsigned int q=0;q<hitPlaneList.size();q++){
		//Is X plane?
		if(hitPlaneList[q]%2==0){
			for(unsigned int k=q+1;k<hitPlaneList.size();k++){	
				//check for X-Y combinations
				if( (hitPlaneList[k]%2==1) && (hitPlaneList[k]-hitPlaneList[q]==1) ){
					planeMultiplicity++;
					break;	
				}
			}//end loop
		}//end if
	}//end loop


	//Determine event type
	switch(planeMultiplicity){
		case eOneFold:
		{
			thisEventTag= eOneFold;
			break;
		}
		case eTwoFold:
		{
			thisEventTag= eTwoFold;
			break;
		}
		case eThreeFold:
		{
			thisEventTag= eThreeFold;
			break;
		}
		default:
			thisEventTag= eSinglePlane;
			break;	
	}//close switch

	return thisEventTag;

}//close TStationSimData::StationEventTagger()



void TStationSimData::AddMuonCount(std::vector<double> counts, std::string dir){

	
	unsigned int size= counts.size();

	if(dir.compare(std::string("in")) == 0){
		if(fMuonNumber.empty()){
			fMuonNumber.clear();
			fMuonNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fMuonNumber.size();i++)
			fMuonNumber[i]+= counts[i];
	}//end if incoming counts
	else if(dir.compare(std::string("out")) == 0){
		if(fMuonAlbedoNumber.empty()){
			fMuonAlbedoNumber.clear();
			fMuonAlbedoNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fMuonAlbedoNumber.size();i++)
			fMuonAlbedoNumber[i]+= counts[i];
	}
	else{
		cerr<<"TStationSimData::AddMuonCount(): Invalid direction option..exit"<<endl; 
		exit(1);
	}

}//close AddMuonCount()


void TStationSimData::AddEmCount(std::vector<double> counts, std::string dir){

	unsigned int size= counts.size();

	if(dir.compare(std::string("in")) == 0){
		if(fEmNumber.empty()){
			fEmNumber.clear();
			fEmNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fEmNumber.size();i++)
			fEmNumber[i]+= counts[i];
	}//end if incoming counts
	else if(dir.compare(std::string("out")) == 0){
		if(fEmAlbedoNumber.empty()){
			fEmAlbedoNumber.clear();
			fEmAlbedoNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fEmAlbedoNumber.size();i++)
			fEmAlbedoNumber[i]+= counts[i];
	}
	else{
		cerr<<"TStationSimData::AddEmCount(): Invalid direction option..exit"<<endl; 
		exit(1);
	}

	
}//close AddMuonCount()


void TStationSimData::AddHadronCount(std::vector<double> counts, std::string dir){

	
	unsigned int size= counts.size();

	if(dir.compare(std::string("in")) == 0){
		if(fHadronNumber.empty()){
			fHadronNumber.clear();
			fHadronNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fHadronNumber.size();i++)
			fHadronNumber[i]+= counts[i];
	}//end if incoming counts
	else if(dir.compare(std::string("out")) == 0){
		if(fHadronAlbedoNumber.empty()){
			fHadronAlbedoNumber.clear();
			fHadronAlbedoNumber.assign(size,0);	
		}
		for(unsigned int i=0;i<fHadronAlbedoNumber.size();i++)
			fHadronAlbedoNumber[i]+= counts[i];
	}
	else{
		cerr<<"TStationSimData::AddHadronCount(): Invalid direction option..exit"<<endl; 
		exit(1);
	}

}//close AddHadronCount()


void TStationSimData::MakePMTSimulation(){

	//do PMT sim only for selected strip hits (triggered strips)
	unsigned int nTrigStrips= fSelScintHitCollection.size();

	for(int i=0;i<nTrigStrips;i++){
		TScintHit hit= fSelScintHitCollection[i];//current hit strip	

		int StripId= hit.StripId;
		int PlaneId= hit.PlaneId;
		int SuperPlaneId= hit.SuperPlaneId;
		int AbsPlaneId= 2*SuperPlaneId+PlaneId;
		std::vector<TVector3> PhotocathodeSurfPosList= hit.PhotocathodeSurfacePosition;

		
		//loop over all hits for this strip
		unsigned int nHitsForThisStrip= (hit.Edep).size();
		for(unsigned int j=0;j<nHitsForThisStrip;j++){	
			double Edep= hit.Edep[j];	
			double Time= hit.Time[j];		
			TVector3 Position= hit.Position[j];
			
			//loop over all PMTs for this strip
			for(unsigned int k=0;k<PhotocathodeSurfPosList.size();k++){
				TVector3 PhotocathodeSurfPosition= PhotocathodeSurfPosList[k];
				TVector3 HitPMTDistance= PhotocathodeSurfPosition-Position;
				double HitPMTHorizontalDistance= 0.;

				if(AbsPlaneId%2==0){//X plane: take distance in x
					HitPMTHorizontalDistance= fabs(HitPMTDistance.X());
				}
				else if(AbsPlaneId%2==1){//Y plane: take distance in y
					HitPMTHorizontalDistance= fabs(HitPMTDistance.Y());
				}

				PMTSimulator* fPMTSimulator= new PMTSimulator();
			
				//fPMTSimulator->SetTransitTime(G4MuonCounterConstruction::fPMTTransitTimeAverage);
				//fPMTSimulator->SetTransitTimeSpread(G4MuonCounterConstruction::fPMTTransitTimeSpread);
				//fPMTSimulator->SetScintillatorDecayTime(G4MuonCounterConstruction::fStripDecayTime);
				fPMTSimulator->SetFiberDecayTime(G4MuonCounterConstruction::GetFiberDecayTime());
				fPMTSimulator->SetFiberCriticalAngle(G4MuonCounterConstruction::GetFiberCriticalAngle());
				//fPMTSimulator->SetFiberCoreRefractiveIndex(G4MuonCounterConstruction::fFiberCoreRefractiveIndex);
				//fPMTSimulator->SetPhotoelectronYield(G4MuonCounterConstruction::fPMTPhotoelectronYield);
				//fPMTSimulator->SetParametrizationSmearingWidth(G4MuonCounterConstruction::fFastSimulationSmearing);
			
				fPMTSimulator->Init();
						
				//## generate photons from parametrization, given x & Edep
				//fPMTSimulator->GeneratePhotonsFast(HitPMTHorizontalDistance,Edep);
				
				//## generate photoelectrons from parametrization, given x & Edep
				fPMTSimulator->GeneratePEFast(HitPMTHorizontalDistance,Edep);

				int PECounts= fPMTSimulator->GetPECounts();
				int PhotonCounts= fPMTSimulator->GetPhotonCounts();
				delete fPMTSimulator;

			}//end loop PMTs
		}//end loop nHits for this strip
		
	}//end loop triggered strips


}//close MakePMTSimulation()


ClassImp(TStationSimData)

#ifdef __MAKECINT__
#pragma link C++ class TStationSimData+; 
#endif

#ifdef __MAKECINT__
#pragma link C++ class std::vector<TStationSimData*>+;
#endif

#ifdef __MAKECINT__
#pragma link C++ class std::vector<TStationSimData>+;
#endif

