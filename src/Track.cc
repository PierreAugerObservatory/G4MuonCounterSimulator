/**
* @file Track.cc
* @class Track
* @brief Define a track in detector
*
* A Track class is created for a couple of detector plane X-Y if the Edep, Npe or Nph is above threshold for the X & Y strips 
* A ROOT dictionary for this class is generated by the Makefile
* @author Dr. Simone Riggi
* @date 07/09/2010
*/

#include "Track.hh"
#include "TrackPoint.hh"

#include <TGeoTrack.h>
#include <TVirtualGeoTrack.h>

#include <iomanip>
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <string>
#include <stdexcept>
#include <algorithm>
#include <math.h>
#include <assert.h>

using namespace std;

/*
Track::Track()
{

	fPointsDetId.clear();
	fPointsDetId.resize(0);

}//close constructor

Track::~Track()
{

}//close destructor
*/


Track::Track()
{
	fPointsSize = 0;
  fNpoints   = 0;
  fPoints    = 0;

	fPointsErrSize = 0;
  fNpointsErr   = 0;
	fPointsErr = 0;

	fTrackPointCollection.clear();
	fTrackPointCollection.resize(0);

	fTrackHitChi2.clear();
	fTrackHitChi2.resize(0);

	fTrackHitExpChi2.clear();
	fTrackHitExpChi2.resize(0);

	fPointsDetId.clear();
	fPointsDetId.resize(0);
}//close constructor

/*
Track::Track()
	: TGeoTrack()
{
	fPointsSize = 0;
  fNpoints   = 0;
  fPoints    = 0;
	fPointsDetId.clear();
	fPointsDetId.resize(0);
}//close constructor
*/

Track::~Track()
{
	if (fPoints) delete [] fPoints;
	if (fPointsErr) delete [] fPointsErr;
}//close destructor


void Track::AddPointError(double xErr, double yErr, double zErr, double tErr){

	//cout<<"Track::AddPointError()"<<endl;

	// Add a point error on the track.
  if(!fPointsErr) {
  	fPointsErrSize = 16;
    fPointsErr = new double[fPointsErrSize];
   } 
	else {
  	if (fNpointsErr>=fPointsErrSize) {
    	double* temp2 = new double[2*fPointsErrSize];
    	memcpy(temp2, fPointsErr, fNpointsErr*sizeof(double));
    	fPointsErrSize *= 2;
    	delete [] fPointsErr;
    	fPointsErr = temp2;
  	}
  }
  fPointsErr[fNpointsErr++] = xErr;      
  fPointsErr[fNpointsErr++] = yErr;      
  fPointsErr[fNpointsErr++] = zErr;      
  fPointsErr[fNpointsErr++] = tErr;   
	
}


int Track::GetPointError(int i, double &xErr, double &yErr, double &zErr, double &tErr) const{

	//cout<<"Track::GetPointError()"<<endl;

	//## Get coordinates for point I on the track.
  int np = fNpointsErr>>2;
  if (i<0 || i>=np) {
  	cerr<< "Track::GetPointError(): no point i="<< i <<", indmax="<< np-1<<endl;	
		return -1;
  }
  int icrt = 4*i;   
  xErr = fPointsErr[icrt];
  yErr = fPointsErr[icrt+1];
  zErr = fPointsErr[icrt+2];
  tErr = fPointsErr[icrt+3];
	//cout<<"xErr="<<xErr<<"  yErr="<<yErr<<"  zErr="<<zErr<<endl;

	return i;
}


void Track::AddTrackPoint(TrackPoint aPoint){

	fTrackPointCollection.push_back(aPoint);
}


int Track::GetTrackPoint(int i, TrackPoint &aPoint) const{

	int np = (int)(fTrackPointCollection.size());
  if (i<0 || i>=np) {
  	cerr<< "Track::GetPointError(): no point i="<< i <<", indmax="<< np-1<<endl;	
		return -1;
  }
	aPoint = fTrackPointCollection[i];
  
	return i;
}

int Track::GetTrackHitChi2(int i, double &Chi2) const{

	int np = (int)(fTrackHitChi2.size());
  if (i<0 || i>=np) {
  	cerr<< "Track::GetTrackHitChi2(): no point i="<< i <<", indmax="<< np-1<<endl;	
		return -1;
  }
	Chi2 = fTrackHitChi2[i];
  
	return i;
}

int Track::GetTrackHitExpChi2(int i, double &Chi2) const{

	int np = (int)(fTrackHitExpChi2.size());
  if (i<0 || i>=np) {
  	cerr<< "Track::GetTrackHitExpChi2(): no point i="<< i <<", indmax="<< np-1<<endl;	
		return -1;
  }
	Chi2 = fTrackHitExpChi2[i];
  
	return i;
}

ClassImp(Track)

#ifdef __MAKECINT__
#pragma link C++ class Track+; 
#endif

#ifdef __MAKECINT__
#pragma link C++ class std::vector<Track*>+;
#endif

#ifdef __MAKECINT__
#pragma link C++ class std::vector<Track>+;
#endif

